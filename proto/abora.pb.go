// Code generated by protoc-gen-go.
// source: proto/abora.proto
// DO NOT EDIT!

/*
Package aborapb is a generated protocol buffer package.

It is generated from these files:
	proto/abora.proto

It has these top-level messages:
	SpectrumPoint
	Spectrum
	DoubleOrHold
	NoOptions
	Oscillator
	PointSettings
	Point
	ADSREnvelope
	Envelope
	Context
	Chirp
	Chirps
*/
package aborapb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type SpectrumPoint struct {
	Amplitude     float64 `protobuf:"fixed64,1,opt,name=amplitude" json:"amplitude,omitempty"`
	Frequency     float64 `protobuf:"fixed64,2,opt,name=frequency" json:"frequency,omitempty"`
	Phase         float64 `protobuf:"fixed64,5,opt,name=phase" json:"phase,omitempty"`
	LowFrequency  float64 `protobuf:"fixed64,3,opt,name=low_frequency" json:"low_frequency,omitempty"`
	HighFrequency float64 `protobuf:"fixed64,4,opt,name=high_frequency" json:"high_frequency,omitempty"`
}

func (m *SpectrumPoint) Reset()                    { *m = SpectrumPoint{} }
func (m *SpectrumPoint) String() string            { return proto.CompactTextString(m) }
func (*SpectrumPoint) ProtoMessage()               {}
func (*SpectrumPoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Spectrum struct {
	Points           []*SpectrumPoint `protobuf:"bytes,1,rep,name=points" json:"points,omitempty"`
	NominalFrequency float64          `protobuf:"fixed64,2,opt,name=nominal_frequency" json:"nominal_frequency,omitempty"`
}

func (m *Spectrum) Reset()                    { *m = Spectrum{} }
func (m *Spectrum) String() string            { return proto.CompactTextString(m) }
func (*Spectrum) ProtoMessage()               {}
func (*Spectrum) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Spectrum) GetPoints() []*SpectrumPoint {
	if m != nil {
		return m.Points
	}
	return nil
}

type DoubleOrHold struct {
	// Types that are valid to be assigned to ValueOrHold:
	//	*DoubleOrHold_Value
	//	*DoubleOrHold_Hold
	ValueOrHold isDoubleOrHold_ValueOrHold `protobuf_oneof:"ValueOrHold"`
}

func (m *DoubleOrHold) Reset()                    { *m = DoubleOrHold{} }
func (m *DoubleOrHold) String() string            { return proto.CompactTextString(m) }
func (*DoubleOrHold) ProtoMessage()               {}
func (*DoubleOrHold) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isDoubleOrHold_ValueOrHold interface {
	isDoubleOrHold_ValueOrHold()
}

type DoubleOrHold_Value struct {
	Value float64 `protobuf:"fixed64,1,opt,name=value,oneof"`
}
type DoubleOrHold_Hold struct {
	Hold bool `protobuf:"varint,2,opt,name=hold,oneof"`
}

func (*DoubleOrHold_Value) isDoubleOrHold_ValueOrHold() {}
func (*DoubleOrHold_Hold) isDoubleOrHold_ValueOrHold()  {}

func (m *DoubleOrHold) GetValueOrHold() isDoubleOrHold_ValueOrHold {
	if m != nil {
		return m.ValueOrHold
	}
	return nil
}

func (m *DoubleOrHold) GetValue() float64 {
	if x, ok := m.GetValueOrHold().(*DoubleOrHold_Value); ok {
		return x.Value
	}
	return 0
}

func (m *DoubleOrHold) GetHold() bool {
	if x, ok := m.GetValueOrHold().(*DoubleOrHold_Hold); ok {
		return x.Hold
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DoubleOrHold) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DoubleOrHold_OneofMarshaler, _DoubleOrHold_OneofUnmarshaler, _DoubleOrHold_OneofSizer, []interface{}{
		(*DoubleOrHold_Value)(nil),
		(*DoubleOrHold_Hold)(nil),
	}
}

func _DoubleOrHold_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DoubleOrHold)
	// ValueOrHold
	switch x := m.ValueOrHold.(type) {
	case *DoubleOrHold_Value:
		b.EncodeVarint(1<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.Value))
	case *DoubleOrHold_Hold:
		t := uint64(0)
		if x.Hold {
			t = 1
		}
		b.EncodeVarint(2<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("DoubleOrHold.ValueOrHold has unexpected type %T", x)
	}
	return nil
}

func _DoubleOrHold_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DoubleOrHold)
	switch tag {
	case 1: // ValueOrHold.value
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.ValueOrHold = &DoubleOrHold_Value{math.Float64frombits(x)}
		return true, err
	case 2: // ValueOrHold.hold
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ValueOrHold = &DoubleOrHold_Hold{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _DoubleOrHold_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DoubleOrHold)
	// ValueOrHold
	switch x := m.ValueOrHold.(type) {
	case *DoubleOrHold_Value:
		n += proto.SizeVarint(1<<3 | proto.WireFixed64)
		n += 8
	case *DoubleOrHold_Hold:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type NoOptions struct {
}

func (m *NoOptions) Reset()                    { *m = NoOptions{} }
func (m *NoOptions) String() string            { return proto.CompactTextString(m) }
func (*NoOptions) ProtoMessage()               {}
func (*NoOptions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type Oscillator struct {
	// Types that are valid to be assigned to Oscillators:
	//	*Oscillator_Sine
	//	*Oscillator_Square
	//	*Oscillator_Spectrum
	Oscillators isOscillator_Oscillators `protobuf_oneof:"Oscillators"`
}

func (m *Oscillator) Reset()                    { *m = Oscillator{} }
func (m *Oscillator) String() string            { return proto.CompactTextString(m) }
func (*Oscillator) ProtoMessage()               {}
func (*Oscillator) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isOscillator_Oscillators interface {
	isOscillator_Oscillators()
}

type Oscillator_Sine struct {
	Sine *NoOptions `protobuf:"bytes,1,opt,name=sine,oneof"`
}
type Oscillator_Square struct {
	Square *NoOptions `protobuf:"bytes,2,opt,name=square,oneof"`
}
type Oscillator_Spectrum struct {
	Spectrum *Spectrum `protobuf:"bytes,3,opt,name=spectrum,oneof"`
}

func (*Oscillator_Sine) isOscillator_Oscillators()     {}
func (*Oscillator_Square) isOscillator_Oscillators()   {}
func (*Oscillator_Spectrum) isOscillator_Oscillators() {}

func (m *Oscillator) GetOscillators() isOscillator_Oscillators {
	if m != nil {
		return m.Oscillators
	}
	return nil
}

func (m *Oscillator) GetSine() *NoOptions {
	if x, ok := m.GetOscillators().(*Oscillator_Sine); ok {
		return x.Sine
	}
	return nil
}

func (m *Oscillator) GetSquare() *NoOptions {
	if x, ok := m.GetOscillators().(*Oscillator_Square); ok {
		return x.Square
	}
	return nil
}

func (m *Oscillator) GetSpectrum() *Spectrum {
	if x, ok := m.GetOscillators().(*Oscillator_Spectrum); ok {
		return x.Spectrum
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Oscillator) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Oscillator_OneofMarshaler, _Oscillator_OneofUnmarshaler, _Oscillator_OneofSizer, []interface{}{
		(*Oscillator_Sine)(nil),
		(*Oscillator_Square)(nil),
		(*Oscillator_Spectrum)(nil),
	}
}

func _Oscillator_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Oscillator)
	// Oscillators
	switch x := m.Oscillators.(type) {
	case *Oscillator_Sine:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Sine); err != nil {
			return err
		}
	case *Oscillator_Square:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Square); err != nil {
			return err
		}
	case *Oscillator_Spectrum:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Spectrum); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Oscillator.Oscillators has unexpected type %T", x)
	}
	return nil
}

func _Oscillator_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Oscillator)
	switch tag {
	case 1: // Oscillators.sine
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NoOptions)
		err := b.DecodeMessage(msg)
		m.Oscillators = &Oscillator_Sine{msg}
		return true, err
	case 2: // Oscillators.square
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NoOptions)
		err := b.DecodeMessage(msg)
		m.Oscillators = &Oscillator_Square{msg}
		return true, err
	case 3: // Oscillators.spectrum
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Spectrum)
		err := b.DecodeMessage(msg)
		m.Oscillators = &Oscillator_Spectrum{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Oscillator_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Oscillator)
	// Oscillators
	switch x := m.Oscillators.(type) {
	case *Oscillator_Sine:
		s := proto.Size(x.Sine)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Oscillator_Square:
		s := proto.Size(x.Square)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Oscillator_Spectrum:
		s := proto.Size(x.Spectrum)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PointSettings struct {
	Freq            *DoubleOrHold `protobuf:"bytes,1,opt,name=freq" json:"freq,omitempty"`
	Amplitude       *DoubleOrHold `protobuf:"bytes,2,opt,name=amplitude" json:"amplitude,omitempty"`
	TremoloStrength *DoubleOrHold `protobuf:"bytes,3,opt,name=tremolo_strength" json:"tremolo_strength,omitempty"`
	TremoloFreq     *DoubleOrHold `protobuf:"bytes,4,opt,name=tremolo_freq" json:"tremolo_freq,omitempty"`
	VibratoStrength *DoubleOrHold `protobuf:"bytes,5,opt,name=vibrato_strength" json:"vibrato_strength,omitempty"`
	VibratoFreq     *DoubleOrHold `protobuf:"bytes,6,opt,name=vibrato_freq" json:"vibrato_freq,omitempty"`
}

func (m *PointSettings) Reset()                    { *m = PointSettings{} }
func (m *PointSettings) String() string            { return proto.CompactTextString(m) }
func (*PointSettings) ProtoMessage()               {}
func (*PointSettings) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *PointSettings) GetFreq() *DoubleOrHold {
	if m != nil {
		return m.Freq
	}
	return nil
}

func (m *PointSettings) GetAmplitude() *DoubleOrHold {
	if m != nil {
		return m.Amplitude
	}
	return nil
}

func (m *PointSettings) GetTremoloStrength() *DoubleOrHold {
	if m != nil {
		return m.TremoloStrength
	}
	return nil
}

func (m *PointSettings) GetTremoloFreq() *DoubleOrHold {
	if m != nil {
		return m.TremoloFreq
	}
	return nil
}

func (m *PointSettings) GetVibratoStrength() *DoubleOrHold {
	if m != nil {
		return m.VibratoStrength
	}
	return nil
}

func (m *PointSettings) GetVibratoFreq() *DoubleOrHold {
	if m != nil {
		return m.VibratoFreq
	}
	return nil
}

type Point struct {
	// Relative time; first should be 0. Must be ascending.
	T        float64        `protobuf:"fixed64,1,opt,name=t" json:"t,omitempty"`
	Settings *PointSettings `protobuf:"bytes,2,opt,name=settings" json:"settings,omitempty"`
}

func (m *Point) Reset()                    { *m = Point{} }
func (m *Point) String() string            { return proto.CompactTextString(m) }
func (*Point) ProtoMessage()               {}
func (*Point) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Point) GetSettings() *PointSettings {
	if m != nil {
		return m.Settings
	}
	return nil
}

type ADSREnvelope struct {
	AttackDuration  float64 `protobuf:"fixed64,1,opt,name=attack_duration" json:"attack_duration,omitempty"`
	DecayDuration   float64 `protobuf:"fixed64,2,opt,name=decay_duration" json:"decay_duration,omitempty"`
	ReleaseDuration float64 `protobuf:"fixed64,3,opt,name=release_duration" json:"release_duration,omitempty"`
	SustainLevel    float64 `protobuf:"fixed64,4,opt,name=sustain_level" json:"sustain_level,omitempty"`
}

func (m *ADSREnvelope) Reset()                    { *m = ADSREnvelope{} }
func (m *ADSREnvelope) String() string            { return proto.CompactTextString(m) }
func (*ADSREnvelope) ProtoMessage()               {}
func (*ADSREnvelope) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type Envelope struct {
	// Types that are valid to be assigned to EnvelopeKind:
	//	*Envelope_Adsr
	EnvelopeKind isEnvelope_EnvelopeKind `protobuf_oneof:"EnvelopeKind"`
}

func (m *Envelope) Reset()                    { *m = Envelope{} }
func (m *Envelope) String() string            { return proto.CompactTextString(m) }
func (*Envelope) ProtoMessage()               {}
func (*Envelope) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isEnvelope_EnvelopeKind interface {
	isEnvelope_EnvelopeKind()
}

type Envelope_Adsr struct {
	Adsr *ADSREnvelope `protobuf:"bytes,1,opt,name=adsr,oneof"`
}

func (*Envelope_Adsr) isEnvelope_EnvelopeKind() {}

func (m *Envelope) GetEnvelopeKind() isEnvelope_EnvelopeKind {
	if m != nil {
		return m.EnvelopeKind
	}
	return nil
}

func (m *Envelope) GetAdsr() *ADSREnvelope {
	if x, ok := m.GetEnvelopeKind().(*Envelope_Adsr); ok {
		return x.Adsr
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Envelope) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Envelope_OneofMarshaler, _Envelope_OneofUnmarshaler, _Envelope_OneofSizer, []interface{}{
		(*Envelope_Adsr)(nil),
	}
}

func _Envelope_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Envelope)
	// EnvelopeKind
	switch x := m.EnvelopeKind.(type) {
	case *Envelope_Adsr:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Adsr); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Envelope.EnvelopeKind has unexpected type %T", x)
	}
	return nil
}

func _Envelope_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Envelope)
	switch tag {
	case 1: // EnvelopeKind.adsr
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ADSREnvelope)
		err := b.DecodeMessage(msg)
		m.EnvelopeKind = &Envelope_Adsr{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Envelope_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Envelope)
	// EnvelopeKind
	switch x := m.EnvelopeKind.(type) {
	case *Envelope_Adsr:
		s := proto.Size(x.Adsr)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Context struct {
	Initial    *PointSettings `protobuf:"bytes,1,opt,name=initial" json:"initial,omitempty"`
	Envelope   *Envelope      `protobuf:"bytes,2,opt,name=envelope" json:"envelope,omitempty"`
	Oscillator *Oscillator    `protobuf:"bytes,3,opt,name=oscillator" json:"oscillator,omitempty"`
}

func (m *Context) Reset()                    { *m = Context{} }
func (m *Context) String() string            { return proto.CompactTextString(m) }
func (*Context) ProtoMessage()               {}
func (*Context) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Context) GetInitial() *PointSettings {
	if m != nil {
		return m.Initial
	}
	return nil
}

func (m *Context) GetEnvelope() *Envelope {
	if m != nil {
		return m.Envelope
	}
	return nil
}

func (m *Context) GetOscillator() *Oscillator {
	if m != nil {
		return m.Oscillator
	}
	return nil
}

type Chirp struct {
	BeginTime       float64  `protobuf:"fixed64,1,opt,name=begin_time" json:"begin_time,omitempty"`
	Duration        float64  `protobuf:"fixed64,2,opt,name=duration" json:"duration,omitempty"`
	Points          []*Point `protobuf:"bytes,3,rep,name=points" json:"points,omitempty"`
	ContextOverride *Context `protobuf:"bytes,4,opt,name=context_override" json:"context_override,omitempty"`
}

func (m *Chirp) Reset()                    { *m = Chirp{} }
func (m *Chirp) String() string            { return proto.CompactTextString(m) }
func (*Chirp) ProtoMessage()               {}
func (*Chirp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Chirp) GetPoints() []*Point {
	if m != nil {
		return m.Points
	}
	return nil
}

func (m *Chirp) GetContextOverride() *Context {
	if m != nil {
		return m.ContextOverride
	}
	return nil
}

type Chirps struct {
	Chirp    []*Chirp `protobuf:"bytes,1,rep,name=chirp" json:"chirp,omitempty"`
	Defaults *Context `protobuf:"bytes,2,opt,name=defaults" json:"defaults,omitempty"`
}

func (m *Chirps) Reset()                    { *m = Chirps{} }
func (m *Chirps) String() string            { return proto.CompactTextString(m) }
func (*Chirps) ProtoMessage()               {}
func (*Chirps) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Chirps) GetChirp() []*Chirp {
	if m != nil {
		return m.Chirp
	}
	return nil
}

func (m *Chirps) GetDefaults() *Context {
	if m != nil {
		return m.Defaults
	}
	return nil
}

func init() {
	proto.RegisterType((*SpectrumPoint)(nil), "aborapb.SpectrumPoint")
	proto.RegisterType((*Spectrum)(nil), "aborapb.Spectrum")
	proto.RegisterType((*DoubleOrHold)(nil), "aborapb.DoubleOrHold")
	proto.RegisterType((*NoOptions)(nil), "aborapb.NoOptions")
	proto.RegisterType((*Oscillator)(nil), "aborapb.Oscillator")
	proto.RegisterType((*PointSettings)(nil), "aborapb.PointSettings")
	proto.RegisterType((*Point)(nil), "aborapb.Point")
	proto.RegisterType((*ADSREnvelope)(nil), "aborapb.ADSREnvelope")
	proto.RegisterType((*Envelope)(nil), "aborapb.Envelope")
	proto.RegisterType((*Context)(nil), "aborapb.Context")
	proto.RegisterType((*Chirp)(nil), "aborapb.Chirp")
	proto.RegisterType((*Chirps)(nil), "aborapb.Chirps")
}

var fileDescriptor0 = []byte{
	// 613 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x54, 0x5d, 0x4f, 0x14, 0x31,
	0x14, 0x65, 0xd9, 0x9d, 0x65, 0xb9, 0xfb, 0xc1, 0x6e, 0x0d, 0xb8, 0x3e, 0x68, 0x4c, 0x15, 0xd9,
	0x68, 0x02, 0x09, 0xbe, 0x1a, 0x13, 0x04, 0x13, 0x12, 0xa2, 0x18, 0x49, 0x7c, 0x9d, 0x74, 0x66,
	0xca, 0x4e, 0x63, 0xb7, 0x1d, 0xda, 0xce, 0x2a, 0x6f, 0xfe, 0x00, 0x7f, 0x81, 0xbf, 0xd6, 0x4e,
	0xa7, 0x33, 0xc3, 0x42, 0x80, 0xb7, 0xf6, 0xf6, 0xf6, 0xdc, 0x73, 0x4f, 0xcf, 0x2d, 0x4c, 0x32,
	0x25, 0x8d, 0x3c, 0x20, 0x91, 0x54, 0x64, 0xdf, 0xad, 0xd1, 0x86, 0xdb, 0x64, 0x11, 0xd6, 0x30,
	0xbc, 0xc8, 0x68, 0x6c, 0x54, 0xbe, 0xf8, 0x26, 0x99, 0x30, 0x68, 0x02, 0x9b, 0x64, 0x91, 0x71,
	0x66, 0xf2, 0x84, 0x4e, 0x5b, 0x2f, 0x5b, 0xb3, 0x56, 0x11, 0xba, 0x54, 0xf4, 0x2a, 0xa7, 0x22,
	0xbe, 0x9e, 0xae, 0xbb, 0xd0, 0x10, 0x82, 0x2c, 0x25, 0x9a, 0x4e, 0x03, 0xb7, 0xdd, 0x86, 0x21,
	0x97, 0xbf, 0xc2, 0x26, 0xab, 0xed, 0xc2, 0x3b, 0x30, 0x4a, 0xd9, 0x3c, 0xbd, 0x11, 0xef, 0x14,
	0x71, 0xfc, 0x05, 0x7a, 0x55, 0x51, 0xf4, 0x06, 0xba, 0x59, 0x51, 0x58, 0xdb, 0x62, 0xed, 0x59,
	0xff, 0x70, 0x67, 0xdf, 0x53, 0xdb, 0x5f, 0xe5, 0xf5, 0x0c, 0x26, 0x42, 0x2e, 0x98, 0x20, 0x3c,
	0xbc, 0x45, 0x06, 0x7f, 0x84, 0xc1, 0x89, 0xcc, 0x23, 0x4e, 0xcf, 0xd5, 0xa9, 0xe4, 0x09, 0xda,
	0x82, 0x60, 0x49, 0x78, 0xee, 0xe9, 0x9f, 0xae, 0xa1, 0x11, 0x74, 0x52, 0x7b, 0xe0, 0xd2, 0x7b,
	0xa7, 0x6b, 0x9f, 0x86, 0xd0, 0xff, 0x51, 0x24, 0x94, 0xf9, 0xb8, 0x0f, 0x9b, 0x5f, 0xe5, 0x79,
	0x66, 0x98, 0x14, 0x1a, 0xff, 0x6d, 0x01, 0x9c, 0xeb, 0x98, 0x71, 0x4e, 0x8c, 0x54, 0x08, 0x43,
	0x47, 0x33, 0x51, 0x42, 0xf5, 0x0f, 0x51, 0x4d, 0xae, 0xbe, 0x60, 0xe1, 0x5f, 0x43, 0x57, 0x5f,
	0xe5, 0x44, 0x51, 0x57, 0xe0, 0xbe, 0xac, 0x5d, 0xe8, 0x69, 0xdf, 0x91, 0x93, 0xa7, 0x7f, 0x38,
	0xb9, 0xd3, 0x6a, 0xc9, 0xad, 0x29, 0xaf, 0xf1, 0xbf, 0x75, 0x18, 0x3a, 0x01, 0x2e, 0xa8, 0x31,
	0x4c, 0xcc, 0x35, 0x7a, 0x05, 0x9d, 0x42, 0x00, 0xcf, 0x68, 0xbb, 0xc6, 0x58, 0x91, 0x60, 0x76,
	0xf3, 0x15, 0xd7, 0x1f, 0xca, 0x3c, 0x80, 0xb1, 0x51, 0x74, 0x21, 0xb9, 0x0c, 0xb5, 0x5d, 0x88,
	0xb9, 0x49, 0x3d, 0xbd, 0x7b, 0x2e, 0xbc, 0x83, 0x41, 0x75, 0xc1, 0xf1, 0xe8, 0x3c, 0x82, 0xbe,
	0x64, 0x91, 0xb2, 0xbd, 0x34, 0xe8, 0xc1, 0x23, 0xe8, 0xd5, 0x05, 0x87, 0xde, 0x7d, 0x20, 0x19,
	0x7f, 0x80, 0xa0, 0x34, 0xc7, 0x26, 0xb4, 0x8c, 0x37, 0xeb, 0xcc, 0xca, 0xec, 0xa5, 0xf2, 0x8d,
	0x37, 0x8e, 0x5a, 0x11, 0x12, 0x67, 0x30, 0x38, 0x3a, 0xb9, 0xf8, 0xfe, 0x59, 0x2c, 0x29, 0x97,
	0x19, 0x45, 0x4f, 0x61, 0x8b, 0x18, 0x43, 0xe2, 0x9f, 0x61, 0x92, 0x5b, 0x02, 0xf6, 0xd9, 0x3c,
	0xa4, 0xb5, 0x71, 0x42, 0x63, 0x72, 0xdd, 0xc4, 0xcb, 0x21, 0x98, 0xc2, 0x58, 0x51, 0x4e, 0xed,
	0x18, 0x34, 0x27, 0xed, 0x6a, 0x1e, 0x74, 0xae, 0x0d, 0x61, 0x22, 0xe4, 0xd4, 0xc2, 0x7b, 0xdf,
	0x1f, 0x41, 0xaf, 0xae, 0xb6, 0x0b, 0x1d, 0x92, 0x68, 0x75, 0xe7, 0x19, 0x6f, 0x52, 0xb2, 0x76,
	0x18, 0xc1, 0xa0, 0xda, 0x9d, 0x31, 0x91, 0xe0, 0x3f, 0x2d, 0xd8, 0x38, 0x96, 0xc2, 0xd0, 0xdf,
	0x06, 0xed, 0xc1, 0x06, 0x13, 0xcc, 0x30, 0xc2, 0x3d, 0xca, 0x3d, 0x9d, 0x5a, 0xcb, 0xf4, 0xa8,
	0x07, 0xf1, 0x9a, 0x34, 0xd6, 0xab, 0x09, 0xed, 0x01, 0xc8, 0xda, 0x78, 0xde, 0x02, 0x4f, 0xea,
	0xb4, 0xc6, 0x93, 0xf8, 0x1a, 0x82, 0xe3, 0x94, 0xa9, 0x0c, 0x21, 0x80, 0x88, 0xce, 0x6d, 0x8f,
	0x86, 0x2d, 0xaa, 0xbf, 0x62, 0x0c, 0xbd, 0x5b, 0x2a, 0xbd, 0xa8, 0x07, 0xbc, 0xed, 0x06, 0x7c,
	0xb4, 0x4a, 0x12, 0xbd, 0x85, 0x71, 0x5c, 0x36, 0x14, 0xca, 0x25, 0x55, 0x8a, 0x59, 0xc7, 0x96,
	0x9e, 0x1a, 0xd7, 0x99, 0xbe, 0x63, 0x7c, 0x06, 0x5d, 0x57, 0x5a, 0xa3, 0xe7, 0x10, 0xc4, 0xc5,
	0xca, 0xff, 0x1a, 0x0d, 0x68, 0x49, 0x0d, 0x5b, 0x1a, 0xf4, 0x92, 0xe4, 0xdc, 0x54, 0x2e, 0xb8,
	0x03, 0x16, 0x75, 0xdd, 0x57, 0xf8, 0xfe, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2b, 0x5c, 0xcd,
	0x5d, 0x1f, 0x05, 0x00, 0x00,
}
